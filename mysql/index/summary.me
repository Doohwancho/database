

---
what is index?


인덱스는 해당 엔티티를 full-scan하면 시간걸리니까, 나중에 꺼내기 쉽게 미리 어떤 기준을 가지고 SORT한 앤데,
그 기준이 A라고 하면, SELECT * FROM TABLE WHERE A라고 하면, 이미 sort되어있는 인덱스 타고 바로 꺼내올 수 있으니까.



Q. 그럼 모든 엔티티에 인덱스 생성하면 좋겠네?

그렇지만도 않은게,

인덱스도 엔티티처럼 오브젝트라 관리해줘야해서, 디비 메모리 잡아먹음.
100만 row 데이터 인덱스 만드려면, 특정 기준에서 sort되었다고 해도 100만 row일거아냐. 



Q. index 단점 있음?

select는 빨라짐. 미리 sort해놓는거라.
대신 insert, update 속도는 느려짐.
매번 원래 entity에 insert, update할 때마다, 해당 entity와 연결된 index에다가 insert, update할 뿐만 아니라, sort됬던걸 다시 sort해야하잖아.



Q. where절 조건이나 composite key중에서, 서순 


1. where절에서 equal조건으로 많이 쓰이는 컬럼이 앞으로 오면 효율적
2. 분별력이 높은 컬럼이 앞에 오면 효율적
    ex. 성별은 1/2토막 밖에 안내줘서 거즘 full-range-scan의 절반 성능임. 안좋음. id같이 분별력 높은 애가 앞에 와야지 바로 인덱스 스캔해서 찾을 수 있음. 왜냐면 숫자면 0~9 10가지 경우의 수를 자릿수마다 비교하며 가니까, 자릿수 비교마다 1/10토막씩 나뉘는 거니까. 알파벳이어도 a-z까지 26분의 1씩 계속 나누는 거니까. 




---
인덱스 고려한 쿼리 방법

1. 인덱스 컬럼 사용
    ex. WHERE SUBSTR(ORDER_NO, 1, 4) = '2019'    ---->    WHERE ORDER_NO LIKE '2019%'
2. 인덱스 컬럼의 묵시적 형변환(같은 타입으로 비교해야 함)
    ex. WHERE REG_DATE = '20190730'    ---->   WHERE REG_DATE = TO_DATE('20190730', 'YYYYMMDD')
3. 인덱스 컬럼 부정형 비교
    ex. WHERE MEM_TYPE != '10'   ---->     WHERE MEM_TYPE IN ('20','30')
4. LIKE 연산자 사용 시 %가 앞에 위치
5. OR 조건 사용 -> UNION ALL로 대체




---
인덱스 손익 분기점


인덱스 탄다고 무조건 속도가 빨라지는게 아니라,
테이블이 가진 전체 데이터 양의 10~15% 내의 데이터가 출력될 때에만 인덱스 타면 효율적인데,
그 이상이 될 땐, 오히려 full-range-scan 이 더 빠르다.
