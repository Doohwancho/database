# what 

1. 드라이빙 테이블(사이즈 작은게 좋음)의 join column을 이용해 해시 테이블 만들고, 
2. 드리븐 테이블(큰 사이즈 테이블) 스캔하면서 해시 테이블에서 매칭하며 찾는 방식 
3. 매칭된걸 조합해서 조인함 



## Q. 언제 씀?

- 대용량 테이블 조인할 때 범위 조인은 sort merge 쓰지만, equal join은 hash join 씀 

## Q. 왜 대용량 테이블 조인할 떄 NL join안하고 hash join 씀?

1. 일단 대용량 = driving table 사이즈 크다 = NL join에 불리 
2. 매번 driven table에 인덱스 타고 찾아야 하는데, 대용량에선 이게 hash 연산인 O(1)보단 느리겠지

```
case1) NL 조인 시간복잡도: O(N×M) (N: 외부 테이블 행 수, M: 내부 테이블 조회 비용)
FOR EACH 외부테이블 행 (N번 반복)
    FOR EACH 내부테이블에서 매칭되는 행 찾기 (인덱스 타도 O(log M))

case2) 해시 조인 시간복잡도: O(N+M) (만약 해시 충돌 없다면) 
1. 작은 테이블 해싱 (O(N))
2. 큰 테이블 스캔하면서 해시테이블 룩업 (O(M×1))
```

해시 조인은 인덱스 안 타고 해시 테이블에서 O(1)에 바로 찾을 수 있음 
대용량 데이터에선 차이 개크게 남



## 실행 과정 

1. 만약 idol_group, idol_member table  이 두 그룹이 있는데,
2. member table이 너무너무 크다. 대용량 테이블.
3. 이 때, idol_group table을 build input으로 삼아서 hash 영역에 저장한다. 
4. hash 영역은 [[PGA]]영역에 있기 때문에 처리속도가 매우 빠르다.
5. idol_group 영역이 hash 영역에 올라가고,
6. idol_member 테이블이 읽히면서 join이 되는 원리.


## example 

case1) NL 조인 실행 (느림)
```
idol_group 100개, idol_member 1,000,000명 가정

FOR EACH 행 IN idol_group (100회 반복)
    idol_member에서 group_id로 매칭되는 행 찾기
    (인덱스 있어도 각 그룹당 평균 10,000명 찾는 작업 필요)

총 작업량: 100 × 인덱스 조회 × 평균 10,000명 처리
```

해시 조인 실행 (빠름)
```
1. idol_group(100행)으로 해시 테이블 생성 (PGA 메모리에 생성, 개빠름)
2. idol_member 1,000,000명 스캔하면서 해시 테이블에서 O(1)에 매칭 찾음

총 작업량: 100(해싱) + 1,000,000(스캔 + 해시 룩업)
```

NL 조인은 인덱스 랜덤 액세스가 지속적으로 발생하는데, 이게 디스크 I/O 병목 일으킴.
해시 조인은 한 번 해시 테이블 만들면 메모리에서 빠르게 조회 가능함!





## 장단점 
- 장점 
    1. memory locality 때문에 빠름 
        - 해시 테이블을 메모리(PGA)에 올려놓고 연속 접근
        - NL 조인은 랜덤 액세스로 디스크 I/O와 버퍼 캐시 효율 저하
    2. hash는 병렬처리에 좋음. 반면 NL join은 병렬처리에 별로임
    3. random access 최소화 
        - NL 조인: 외부 테이블 행마다 내부 테이블을 랜덤하게 접근
        - 해시 조인: 한 번 해시 테이블 생성 후 순차적 스캔만 수행
    4. 인덱스 안걸려 있어도 됨. 어짜피 hash 함수로 찾을거라. 인덱스로 안찾고. 
- 단점 
    1. join하는 컬럼이 범위조인이면 안되고 무조건 equal 연산이어야만 함. 그래야 hash() 돌리지
    2. hash collision 발생할 수록 성능 떨어짐 
    3. 해시 테이블이 메모리(PGA)에 다 안 들어가면 디스크로 넘침 -> swap memory 쓰면 느려짐 
    4. OLTP 환경에서 쓰면 좀... 별로임. 왜냐면 hash 함수 계산이 cpu usage 많이 쓰거든. 
